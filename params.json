{"name":"Ember-can","tagline":"Simple authorisation addon for Ember apps","body":"# Ember-can\r\n\r\nSimple authorisation addon for Ember.\r\n\r\n[![npm version](https://badge.fury.io/js/ember-can.svg)](http://badge.fury.io/js/ember-can)\r\n[![Ember Observer Score](http://emberobserver.com/badges/ember-can.svg)](http://emberobserver.com/addons/ember-can)\r\n[![Build Status](https://travis-ci.org/minutebase/ember-can.svg?branch=master)](https://travis-ci.org/minutebase/ember-can)\r\n\r\n## Breaking Changes\r\n\r\n* v0.6.0 - support for unit testing abilities added - run `ember g ember-can`\r\n* v0.5.0 - support for Ember 1.13+ using new Ember.Helper, removed injections\r\n* v0.4.0 - stopped singularizing ability names to work with pods\r\n* v0.3.0 - removed `if-can` helper, uses sub-expression instead\r\n\r\nSee [UPGRADING](UPGRADING.md) for more details.\r\n\r\n## Quick Example\r\n\r\nYou want to conditionally allow creating a new blog post:\r\n\r\n```handlebars\r\n{{#if (can \"write post\")}}\r\n  <button {{action \"new\"}}>Write Post</button>\r\n{{else}}\r\n  You can't write a new post\r\n{{/if}}\r\n```\r\n\r\nWe define an ability for the `Post` resource in `/app/abilities/post.js`:\r\n\r\n```javascript\r\nimport Ember from 'ember';\r\nimport { Ability } from 'ember-can';\r\n\r\nexport default Ability.extend({\r\n  canWrite: Ember.computed('user.isAdmin', function() {\r\n    return this.get('user.isAdmin');\r\n  })\r\n});\r\n```\r\n\r\nWe can also re-use the same ability to check if a user has access to a route:\r\n\r\n```javascript\r\nimport Ember from 'ember';\r\nimport { CanMixin } from 'ember-can';\r\n\r\nexport default Ember.Route.extend(CanMixin, {\r\n  beforeModel: function() {\r\n    if (!this.can('write post')) {\r\n      this.transitionTo('index');\r\n    }\r\n  }\r\n});\r\n```\r\n\r\n## Installation\r\n\r\nInstall this addon via ember-cli:\r\n\r\n```\r\nember install ember-can\r\n```\r\n\r\n## Compatibility\r\n\r\n| Ember Version     | Ember Can Release     |\r\n| ----------------- | --------------------- |\r\n| 1.9.x             | 0.2                   |\r\n| 1.10 through 1.12 | 0.4                   |\r\n| 1.13 and beyond   | 0.5+                  |\r\n\r\n## Abilities\r\n\r\nAn ability class protects an individual model / resource which is available in the ability as `model`.\r\n\r\nThe ability checks themselves are simply standard Ember objects with computed properties:\r\n\r\n```javascript\r\nimport Ember from 'ember';\r\nimport { Ability } from 'ember-can';\r\n\r\nexport default Ability.extend({\r\n  // only admins can write a post\r\n  canWrite: Ember.computed('user.isAdmin', function() {\r\n    return this.get('user.isAdmin');\r\n  }),\r\n\r\n  // only the person who wrote a post can edit it\r\n  canEdit: Ember.computed('user.id', 'model.author', function() {\r\n    return this.get('user.id') === this.get('model.author');\r\n  })\r\n});\r\n```\r\n\r\n## Handlebars Helpers\r\n\r\nThe `can` helper is meant to be used with `{{if}}` and `{{unless}}` to protect a block.\r\n\r\nThe first parameter is a string which is used to find the ability class call the appropriate property (see [Looking up abilities](#looking-up-abilities)).\r\n\r\nThe second parameter is an optional model object which will be given to the ability to check permissions.\r\n\r\nAs activities are standard Ember objects and computed properties if anything changes then the view will\r\nautomatically update accordingly.\r\n\r\n```handlebars\r\n{{#if (can \"edit post\" post)}}\r\n  ...\r\n{{else}}\r\n  ...\r\n{{/if}}\r\n```\r\n\r\nAs it's a sub-expression, you can use it anywhere a helper can be used.\r\nFor example to give a div a class based on an ability you can use an inline if:\r\n\r\n```handlebars\r\n<div class=\"{{if (can 'edit post' post) 'is-editable'}}\">\r\n\r\n</div>\r\n```\r\n\r\n## Additional attributes\r\n\r\nIf you need more than a single resource in an ability, you can pass them additional attributes.\r\n\r\nYou can do this in the helpers, for example this will set the `model` to `project` as usual,\r\nbut also `member` as a bound property.\r\n\r\n```handlebars\r\n{{#if (can \"remove member from project\" project member=member)}}\r\n  ...\r\n{{/if}}\r\n```\r\n\r\nSimilarly in routes you can pass additional attributes after or instead of the resource:\r\n\r\n```javascript\r\nthis.can('edit post', post, { author: bob });\r\nthis.can('write post', { project: project });\r\n```\r\n\r\nThese will set `author` and `project` on the ability respectively so you can use them in the checks.\r\n\r\n## Looking up abilities\r\n\r\nIn the example above we said `{{#if-can \"write post\"}}`, how do we find the ability class & know which property to use for that?\r\n\r\nFirst we chop off the last word as the resource type which is looked up via the container.\r\n\r\nThe ability file can either be looked up in the top level `/app/abilities` directory, or via pod structure.\r\n\r\nThen for the ability name we remove some basic stopwords (of, for in) at the end, prepend with \"can\" and camelCase it all.\r\n\r\nFor example:\r\n\r\n| String                      | property           | resource                | pod                            |\r\n|-----------------------------|--------------------|-------------------------|--------------------------------|\r\n| write post                  | `canWrite`         | `/abilities/post.js`    | `app/pods/post/ability.js`     |\r\n| manage members in projects  | `canManageMembers` | `/abilities/projects.js`| `app/pods/projects/ability.js` |\r\n| view profile for user       | `canViewProfile`   | `/abilities/user.js`    | `app/pods/user/ability.js`     |\r\n\r\nCurrent stopwords which are ignored are:\r\n\r\n* for\r\n* from\r\n* in\r\n* of\r\n* to\r\n\r\n## Custom Ability Lookup\r\n\r\nThe default lookup is a bit \"clever\"/\"cute\" for some people's tastes, so you can override this if you choose.\r\n\r\nSimply extend the default `CanService` in `app/services/can.js` and override `parse`.\r\n\r\n`parse` takes the ability string eg \"manage members in projects\" and should return an object with `propertyName` and `abilityName`.\r\n\r\nFor example, to use the format \"person.canEdit\" instead of the default \"edit person\" you could do the following:\r\n\r\n```javascript\r\n// app/services/can.js\r\nimport { CanService } from 'ember-can';\r\n\r\nexport default CanService.extend({\r\n  parse(str) {\r\n    const [abilityName, propertyName] = str.split('.');\r\n    return {\r\n      propertyName,\r\n      abilityName\r\n    }\r\n  }\r\n});\r\n```\r\n\r\n## Injecting the user\r\n\r\nHow does the ability know who's logged in? This depends on how you implement it in your app!\r\n\r\nIf you're using an `Ember.Service` as your session, you can just inject it into the ability:\r\n\r\n```javascript\r\n// app/abilities/foo.js\r\nimport Ember from 'ember';\r\nimport { Ability } from 'ember-can';\r\n\r\nexport default Ability.extend({\r\n  session: Ember.inject.service()\r\n});\r\n```\r\n\r\nIf you're using ember-simple-auth, you'll probably want to inject the `simple-auth-session:main` session\r\ninto the ability classes.\r\n\r\nTo do this, add an initializer like so:\r\n\r\n```javascript\r\n// app/initializers/inject-session-into-abilities.js\r\nexport default {\r\n  name: 'inject-session-into-abilities',\r\n  initialize(app) {\r\n    app.inject('ability', 'session', 'simple-auth-session:main');\r\n  }\r\n};\r\n```\r\n\r\nThe ability classes will now have access to `session` which can then be used to check if the user is logged in etc...\r\n\r\n## Controllers, components & computed properties\r\n\r\nIn a controller or component, you may want to expose abilities as computed properties\r\nso that you can bind to them in your templates.\r\n\r\nTo do that there's a helper to lookup the ability for a resource, which you can\r\nthen alias properties:\r\n\r\n```javascript\r\nimport { computed } from 'ember-can';\r\nimport Ember from 'ember';\r\n\r\nexport default Ember.Controller.extend({\r\n  post: null, // set by the router\r\n\r\n  // looks up the \"post\" ability and sets the model as the controller's \"post\" property\r\n  ability: computed.ability('post'),\r\n\r\n  // alias properties to the ability for easier access\r\n  canEditPost: Ember.computed.reads('ability', 'canEdit')\r\n});\r\n```\r\n\r\n`computed.ability` assumes that the property for the resource is the same as the ability resource.\r\nIf that's not the case, include it as the second parameter.\r\n\r\n```javascript\r\nimport { computed } from 'ember-can';\r\nimport Ember from 'ember';\r\n\r\nexport default Ember.Controller.extend({\r\n  // looks up the \"post\" ability and sets the model as the controller's \"content\" property\r\n  ability: computed.ability('post', 'content')\r\n});\r\n```\r\n\r\n## Testing\r\nMake sure that you've either `ember install`-ed this addon, or run the addon\r\nblueprint via `ember g ember-can`. This is an important step that teaches the\r\ntest resolver how to resolve abilities from the file structure.  \r\n\r\nAn ability unit test will be created each time you generate a new ability via\r\n`ember g ability <name>`. The package currently supports generating QUnit and\r\nMocha style tests.  \r\n\r\nTo unit test components that use the `can` helper, you'll need to `needs` the\r\nability and helper file like this:  \r\n``` needs: ['helper:can', 'ability:foo'] ```\r\n\r\n## Development\r\n\r\n### Installation\r\n\r\n* `git clone` this repository\r\n* `npm install`\r\n* `bower install`\r\n\r\n### Running\r\n\r\n* `ember server`\r\n* Visit your app at http://localhost:4200.\r\n\r\n### Running Tests\r\n\r\n* `ember test`\r\n* `ember test --server`\r\n\r\n### Building\r\n\r\n* `ember build`\r\n\r\nFor more information on using ember-cli, visit [http://www.ember-cli.com/](http://www.ember-cli.com/).\r\n","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}